<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebAR with Triple Tap to Place VRM Model</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 999;
    }
    .ar-button {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="overlay"></div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- WebXR Polyfill (for browsers that do not fully support WebXR) -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
  <!-- GLTFLoader for loading VRM models -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- VRM libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@0.6.0"></script>

  <button id="startArButton" class="ar-button">Start AR</button>

  <script>
    const startArButton = document.getElementById('startArButton');
    let vrm; // Global reference to the VRM model
    let lastTap = 0;
    let tapCount = 0;

    // Three.js setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.xr.enabled = true;
    renderer.xr.setReferenceSpaceType('local');
    document.body.appendChild(renderer.domElement);

    // Add light to the scene
    const light = new THREE.DirectionalLight(0xffffff);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);

    // Controller setup
    const controller = renderer.xr.getController(0);
    scene.add(controller);

    // Reticle for hit testing
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
      new THREE.MeshBasicMaterial()
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    let hitTestSource = null;

    // Start AR session
    async function arButtonClick() {
      startArButton.style.display = 'none'; // Hide start button

      const overlayElem = document.getElementById('overlay');
      const options = {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: overlayElem }
      };
      const xrSession = await navigator.xr.requestSession('immersive-ar', options);
      await renderer.xr.setSession(xrSession);

      animate();
    }

    startArButton.addEventListener('click', arButtonClick);

    // VRM model loading and positioning on triple tap
    async function onTripleTap() {
      if (reticle.visible) {
        const loader = new THREE.GLTFLoader();
        const gltf = await loader.loadAsync('./AliciaSolid.vrm');
        THREE.VRMUtils.removeUnnecessaryJoints(gltf.scene);
        
// Dispose of previous model if it exists
if (vrm) {
  scene.remove(vrm.scene);
  vrm.scene.traverse((object) => {
    if (object.isMesh) {
      if (object.geometry) object.geometry.dispose();
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(mat => mat.dispose());
        } else {
          object.material.dispose();
        }
      }
    }
  });
  vrm = null;
}


        // Load and position new VRM model
        vrm = await THREE.VRM.from(gltf);
        vrm.scene.scale.set(0.6, 0.6, 0.6); // Scale down VRM model
        reticle.matrix.decompose(
          vrm.scene.position,
          vrm.scene.quaternion,
          vrm.scene.scale
        );
        vrm.scene.rotation.y = camera.rotation.y + Math.PI;
        scene.add(vrm.scene);
        reticle.visible = false;
      }
    }

    // Triple tap detection
    document.addEventListener('touchend', (event) => {
      const currentTime = new Date().getTime();
      const tapLength = currentTime - lastTap;

      if (tapLength < 300 && tapLength > 0) {
        tapCount++;

        // Triple tap detected
        if (tapCount === 3) {
          onTripleTap();
          tapCount = 0;
        }
      } else {
        tapCount = 1; // Reset count if not a quick sequence
      }

      lastTap = currentTime;
    });

    // Animation loop
    function animate() {
      renderer.setAnimationLoop(render);
    }

    async function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();
        if (!hitTestSource && referenceSpace && session) {
          const space = await session.requestReferenceSpace('viewer');
          hitTestSource = await session.requestHitTestSource({ space });

          session.addEventListener('end', () => {
            hitTestSource = null;
          });
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);
          if (hitTestResults.length && referenceSpace) {
            const hit = hitTestResults[0];
            reticle.visible = true;
            reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
          } else {
            reticle.visible = false;
          }
        }

        renderer.render(scene, camera);
      }
    }
  </script>
</body>
</html>
